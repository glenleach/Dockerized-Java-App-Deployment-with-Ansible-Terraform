# Dockerized Java App Deployment with Ansible & Terraform

**This project is for personal training purposes only as part of DevOps training for Techworld with Nana.**
**It is not for redistribution or commercial use. All rights reserved.**

![App Screenshot](https://github.com/glenleach/Java-mysql-project/blob/master/images/screenshot.PNG?raw=true)

## Project Structure

```
run-docker-applications/
├── ansible.cfg                # Ansible configuration (disables host key checking)
├── deploy-docker-ec2-user.yaml # Ansible playbook for Docker deployment
├── docker-compose.yaml        # Docker Compose file for app stack
├── hosts                      # Ansible inventory (auto-generated by Terraform)
├── main.tf                    # Terraform configuration for AWS infrastructure
├── project-vars.yaml          # Ansible variables (Docker credentials, etc.)
├── server-key.pem             # SSH private key (auto-generated by Terraform)
└── README.md                  # Project documentation (this file)
```

## Prerequisites

- [Terraform](https://www.terraform.io/downloads.html) (v1.0+)
- [Ansible](https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html) (v2.10+)
- [AWS CLI](https://aws.amazon.com/cli/) (configured with credentials)
- An AWS account with permissions to create EC2, VPC, and related resources
- (Optional) Docker installed locally for testing

## Setup & Deployment

### 1. Clone the Repository
```sh
git clone <your-repo-url>
cd run-docker-applications
```

### 2. Configure Terraform Variables
Edit `terraform.tfvars` or set variables as needed for your environment (VPC CIDR, subnet, instance type, etc.).

**Example terraform.tfvars:**
```hcl
vpc_cidr_block   = "10.0.0.0/16"
subnet_cidr_block = "10.0.1.0/24"
avail_zone       = "eu-west-2a"
env_prefix       = "dev"
my_ip            = "203.0.113.0/32" # Your public IP for SSH access
instance_type    = "t3.micro"
image_name       = "al2023-ami-2023.*-x86_64"
```

### 3. Initialize and Apply Terraform
This will provision AWS infrastructure, generate an SSH key, and create/update the Ansible hosts file:
```sh
terraform init
terraform apply
```

**After this step:**
- A key pair file called `server-key.pem` will be generated in your project root. This is used by Ansible (and you) to SSH into the EC2 instances.
- A `hosts` file will be generated in your project root. This file contains the current EC2 public IPs and is used by Ansible as its inventory for deployment.
- Both files are auto-managed by Terraform and always reflect the current infrastructure state.

### 4. Review Generated Files
- `server-key.pem`: SSH private key for EC2 access (auto-generated)
- `hosts`: Ansible inventory with current EC2 public IPs (auto-generated)

### 5. Configure Ansible Variables
Edit `project-vars.yaml` to set your Docker Hub password:

**Example project-vars.yaml:**
```yaml
docker_password: "your_dockerhub_password"
```

### 6. Run the Ansible Playbook
This installs Docker, Docker Compose, deploys your app stack, and logs in to Docker Hub:
```sh
ansible-playbook -i hosts deploy-docker-ec2-user.yaml
```

### 7. Access Your Services
- **Java App:**  
  `http://<EC2_PUBLIC_IP>:8080`
- **phpMyAdmin:**  
  `http://<EC2_PUBLIC_IP>:8083`
- **MySQL:**  
  `<EC2_PUBLIC_IP>:3306` (use credentials from `docker-compose.yaml`)

## SSH Access to EC2

```sh
chmod 600 server-key.pem
ssh -i server-key.pem ec2-user@<EC2_PUBLIC_IP>
```

## Notes
- The `hosts` file is auto-managed by Terraform and always reflects the current EC2 IPs.
- The `server-key.pem` is also auto-generated and should be kept secure.
- The playbook is idempotent and can be run multiple times.
- Docker images are always pulled fresh on deployment (`pull: always`).
- For production, restrict security group rules as needed.

## Cleanup
To destroy all AWS resources:
```sh
terraform destroy
```

---

**For any issues, check the logs/output of Terraform and Ansible for troubleshooting.**
